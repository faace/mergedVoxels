/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./src/Voxels.js":
/*!***********************!*\
  !*** ./src/Voxels.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {// code: faaceyu\r\n// email: faace.ca@gmail.com\r\n\r\n// a cube position\r\n//   7-----6\r\n//  /|    /|\r\n// 3-+---2 |\r\n// | 4---+-5\r\n// |/    |/\r\n// 0-----1\r\n\r\n// a face position\r\n// d c\r\n// a b\r\n(function () {\r\n    var Voxels = function (info) {\r\n        this.init(info);\r\n    };\r\n\r\n    if (typeof window != 'undefined') window.Voxels = Voxels;\r\n    else if (typeof global != 'undefined') global.Voxels = Voxels;\r\n\r\n    if ( true && module.exports) module.exports = Voxels;\r\n\r\n    Voxels.prototype.init = function (info) {\r\n        this.info = info;\r\n        this.options = info.options || {};\r\n        this.map = this.copyMap(info.map || {});\r\n        this.textures = this.info.textures || {};\r\n        this.opacities = this.info.opacities || {};\r\n        this.width = info.width || 1;\r\n        this.height = info.height || 1;\r\n        this.depth = info.depth || 1;\r\n        this.cellSize = info.cellSize || -1;\r\n        this.align = info.align;\r\n        this.showFaces = info.showFaces || { front: true, back: true, left: true, right: true, top: true, bottom: true };\r\n        return this;\r\n    };\r\n    Voxels.prototype.run = function (cb) {\r\n        if (!this.bound) this.bound = this.getBound(this.map);\r\n        this.checkCellSize(this.bound);\r\n        if (!this.center) {\r\n            this.center = {};\r\n            this.pCenter = {};\r\n            this.getCenter(this.align, this.center, this.pCenter);\r\n        }\r\n        var vertices = this.buildVertices();\r\n        var faces = this.buildFaces(vertices);\r\n\r\n        this.updateVertices(vertices);\r\n        this.updateFaces(vertices, faces);\r\n\r\n        this.materials = [];\r\n        this.materialsMap = {};\r\n        this.texturesMap = {};\r\n\r\n        var geometry = this.createGeometry(vertices, faces);\r\n        var mesh = new THREE.Mesh(geometry, this.materials);\r\n        cb(false, mesh, this.centerMap(this.map));\r\n    };\r\n    Voxels.prototype.copyMap = function (map) {\r\n        var newMap = {};\r\n        for (var y in map) {\r\n            var yMap = map[y];\r\n            var newYMap = newMap[y] = {};\r\n            for (var z in yMap) {\r\n                var zMap = yMap[z];\r\n                var newZMap = newYMap[z] = {};\r\n                for (var x in zMap) {\r\n                    newZMap[x] = { color: zMap[x] };\r\n                }\r\n            }\r\n        }\r\n        return newMap;\r\n    };\r\n    Voxels.prototype.centerMap = function (map) {\r\n        var newMap = {}, one;\r\n        var opacities = this.opacities;\r\n        var textures = this.textures;\r\n        for (var y in map) {\r\n            var yMap = map[y];\r\n            var newYMap = newMap[y - this.pCenter.y] = {};\r\n            for (var z in yMap) {\r\n                var zMap = yMap[z];\r\n                var newZMap = newYMap[z - this.pCenter.z] = {};\r\n                for (var x in zMap) {\r\n                    one = { color: zMap[x].color };\r\n                    if (opacities[one.color] && opacities[one.color] < 1) one.opacity = opacities[one.color];\r\n                    if (textures[one.color]) one.texture = textures[one.color];\r\n                    newZMap[x - this.pCenter.x] = one;\r\n                }\r\n            }\r\n        }\r\n        return newMap;\r\n    };\r\n    Voxels.prototype.getMaterial = function (color, s, t) {\r\n        var textures = this.textures;\r\n        var opacity = this.opacities[color];\r\n        var parm = {};\r\n        var material;\r\n\r\n        if (this.options.polygonOffset) {\r\n            parm.polygonOffset = true;\r\n            parm.polygonOffsetFactor = this.options.polygonOffsetFactor || -1.0;\r\n            parm.polygonOffsetUnits = this.options.polygonOffsetUnits || -4.0;\r\n        }\r\n\r\n        if (textures[color]) { // check where we need to change a special color to a texture\r\n            var tag = textures[color];\r\n            var src;\r\n            if (typeof tag != 'string') src = tag.src;\r\n            else {\r\n                var img = document.querySelector('#' + textures[color]);\r\n                src = img && (img.src || img[0] && img[0].src)\r\n            }\r\n            if (src) {\r\n                var texture = new THREE.TextureLoader().load(src);\r\n                texture.wrapS = THREE.RepeatWrapping;\r\n                texture.wrapT = THREE.RepeatWrapping;\r\n                texture.repeat.set(s, t);\r\n\r\n                parm.map = texture;\r\n                material = new THREE.MeshBasicMaterial(parm);\r\n                if (typeof opacity != 'undefined') {\r\n                    material.transparent = true;\r\n                    material.opacity = opacity;\r\n                    // m.side = THREE.DoubleSide;\r\n                }\r\n                return material;\r\n            }\r\n        }\r\n\r\n        parm.color = color;\r\n        material = new THREE.MeshPhongMaterial(parm);\r\n        if (typeof opacity != 'undefined') {\r\n            material.transparent = true;\r\n            material.opacity = opacity;\r\n            // m.side = THREE.DoubleSide;\r\n        }\r\n        return material;\r\n    };\r\n    Voxels.prototype.getMaterialIdx = function (color, s, t) {\r\n        // var color = material.color;\r\n        var tag = color + '_' + s + '_' + t;\r\n        if (typeof this.materialsMap[tag] == 'undefined') {\r\n            var m = this.getMaterial(color, s, t);\r\n            this.materialsMap[tag] = this.materials.length;\r\n            this.materials.push(m);\r\n        }\r\n        return this.materialsMap[tag];\r\n    };\r\n\r\n    Voxels.prototype.createGeometry = function (vertices, faces) {\r\n        var geometry = new THREE.Geometry();\r\n        for (var i = 0; i < vertices.length; i++) {\r\n            if (vertices[i][3]) {\r\n                geometry.vertices.push(new THREE.Vector3(vertices[i][0], vertices[i][1], vertices[i][2]));\r\n            }\r\n        }\r\n        geometry.computeBoundingBox();\r\n\r\n        var faceVertexUv = geometry.faceVertexUvs[0];\r\n        var t0 = new THREE.Vector2(0, 0);\r\n        var t1 = new THREE.Vector2(1, 0);\r\n        var t2 = new THREE.Vector2(1, 1);\r\n        var t3 = new THREE.Vector2(0, 1);\r\n        var uv1 = [t0, t1, t2];\r\n        var uv2 = [t0, t2, t3];\r\n        for (var i = 0, face, idx; i < faces.length; i++) {\r\n            face = faces[i];\r\n            idx = this.getMaterialIdx(face[3].color, face[4], face[5]);\r\n            geometry.faces.push(new THREE.Face3(face[0], face[1], face[2], undefined, undefined, idx));\r\n            faceVertexUv.push(uv1, uv2);\r\n        }\r\n        // geometry.mergeVertices();\r\n        geometry.computeFaceNormals();\r\n        return geometry;\r\n    };\r\n    Voxels.prototype.updateFaces = function (vertices, faces) { // update the faces with new vertices index\r\n        for (var i = 0; i < faces.length; i++) {\r\n            faces[i][0] = vertices[faces[i][0]][4];\r\n            faces[i][1] = vertices[faces[i][1]][4];\r\n            faces[i][2] = vertices[faces[i][2]][4];\r\n        }\r\n    };\r\n    Voxels.prototype.updateVertices = function (vertices) { // mark all the used vertices so that we can remove those unused later.\r\n        var idx = 0;\r\n        for (var i = 0; i < vertices.length; i++) {\r\n            if (vertices[i][3]) vertices[i][4] = idx++;\r\n        }\r\n    };\r\n    Voxels.prototype.isSameMaterial = function (map, x, y, z, color) { // check where there are the same material\r\n        if (map[y] && map[y][z] && typeof map[y][z][x] != 'undefined') {\r\n            if (map[y][z][x] === color) return true;\r\n        }\r\n        return false\r\n    };\r\n    Voxels.prototype.FindAndSetPointBottom = function (bound, map, x, y, z, to) {// 查找同一面的右下角定点和右上角定点\r\n        var face = 'bottom';\r\n        var xx, yy, zz;\r\n        var material = map[y][z][x];\r\n        var noSame;\r\n        to.x = x; to.y = y; to.z = z;\r\n        for (xx = x; xx <= bound.maxX; xx++) { // facing the bottom, left to right and mark\r\n            if (this.canIgnore(map, xx, y, z, xx, y - 1, z)) break;\r\n            if (this.isSameMaterial(map, xx, y, z, material) && !map[y][z][xx][face]) {\r\n                map[y][z][xx][face] = true;\r\n                to.x = xx;\r\n            } else break;\r\n        }\r\n        for (zz = z + 1; zz <= bound.maxZ; zz++) {\r\n            noSame = false;\r\n            for (xx = x; xx <= to.x; xx++) { // bottom to up\r\n                if (this.canIgnore(map, xx, y, zz, xx, y - 1, zz) || !this.isSameMaterial(map, xx, y, zz, material) || map[y][zz][xx][face]) {\r\n                    noSame = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (noSame) break;\r\n            for (xx = x; xx <= to.x; xx++) { // mark\r\n                map[y][zz][xx][face] = true;\r\n            }\r\n            to.z = zz;\r\n        }\r\n    };\r\n    Voxels.prototype.FindAndSetPointTop = function (bound, map, x, y, z, to) {// 查找同一面的右下角定点和右上角定点\r\n        var face = 'top';\r\n        var xx, yy, zz;\r\n        var material = map[y][z][x];\r\n        var noSame;\r\n        to.x = x; to.y = y; to.z = z;\r\n        for (xx = x; xx <= bound.maxX; xx++) { // facing the top, left to right and mark\r\n            if (this.canIgnore(map, xx, y, z, xx, y + 1, z)) break;\r\n            if (this.isSameMaterial(map, xx, y, z, material) && !map[y][z][xx][face]) {\r\n                map[y][z][xx][face] = true;\r\n                to.x = xx;\r\n            } else break;\r\n        }\r\n        for (zz = z - 1; zz >= bound.minZ; zz--) {\r\n            noSame = false;\r\n            for (xx = x; xx <= to.x; xx++) { // bottom to up\r\n                if (this.canIgnore(map, xx, y, zz, xx, y + 1, zz) || !this.isSameMaterial(map, xx, y, zz, material) || map[y][zz][xx][face]) {\r\n                    noSame = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (noSame) break;\r\n            for (xx = x; xx <= to.x; xx++) { // mark\r\n                map[y][zz][xx][face] = true;\r\n            }\r\n            to.z = zz;\r\n        }\r\n    };\r\n\r\n    Voxels.prototype.FindAndSetPointRight = function (bound, map, x, y, z, to) {// 查找同一面的右下角定点和右上角定点\r\n        var face = 'right';\r\n        var xx, yy, zz;\r\n        var material = map[y][z][x];\r\n        var noSame;\r\n        to.x = x; to.y = y; to.z = z;\r\n        for (zz = z; zz >= bound.minZ; zz--) { // facing the rgiht, left to right and mark\r\n            if (this.canIgnore(map, x, y, zz, x + 1, y, zz)) break;\r\n            if (this.isSameMaterial(map, x, y, zz, material) && !map[y][zz][x][face]) {\r\n                map[y][zz][x][face] = true;\r\n                to.z = zz;\r\n            } else break;\r\n        }\r\n        for (yy = y + 1; yy <= bound.maxY; yy++) {\r\n            noSame = false;\r\n            for (zz = z; zz >= to.z; zz--) { // bottom to up\r\n                if (this.canIgnore(map, x, yy, zz, x + 1, yy, zz) || !this.isSameMaterial(map, x, yy, zz, material) || map[yy][zz][x][face]) {\r\n                    noSame = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (noSame) break;\r\n            for (zz = z; zz >= to.z; zz--) { // mark\r\n                map[yy][zz][x][face] = true;\r\n            }\r\n            to.y = yy;\r\n        }\r\n    };\r\n    Voxels.prototype.FindAndSetPointLeft = function (bound, map, x, y, z, to) {// 查找同一面的右下角定点和右上角定点\r\n        var face = 'left';\r\n        var xx, yy, zz;\r\n        var material = map[y][z][x];\r\n        var noSame;\r\n        to.x = x; to.y = y; to.z = z;\r\n        for (zz = z; zz <= bound.maxZ; zz++) { // facing the left, left to right and mark\r\n            if (this.canIgnore(map, x, y, zz, x - 1, y, zz)) break;\r\n            if (this.isSameMaterial(map, x, y, zz, material) && !map[y][zz][x][face]) {\r\n                map[y][zz][x][face] = true;\r\n                to.z = zz;\r\n            } else break;\r\n        }\r\n        for (yy = y + 1; yy <= bound.maxY; yy++) {\r\n            noSame = false;\r\n            for (zz = z; zz <= to.z; zz++) { // bottom to up\r\n                if (this.canIgnore(map, x, yy, zz, x - 1, yy, zz) || !this.isSameMaterial(map, x, yy, zz, material) || map[yy][zz][x][face]) {\r\n                    noSame = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (noSame) break;\r\n            for (zz = z; zz <= to.z; zz++) { // mark\r\n                map[yy][zz][x][face] = true;\r\n            }\r\n            to.y = yy;\r\n        }\r\n    };\r\n\r\n    Voxels.prototype.FindAndSetPointBack = function (bound, map, x, y, z, to) { // find from left-bottom to right-top in back face\r\n        var face = 'back';\r\n        var xx, yy, zz;\r\n        var material = map[y][z][x];\r\n        var noSame;\r\n        to.x = x; to.y = y; to.z = z;\r\n        for (xx = x; xx >= bound.minX; xx--) { // facing the back, left to right and mark\r\n            if (this.canIgnore(map, xx, y, z, xx, y, z - 1)) break;\r\n            if (this.isSameMaterial(map, xx, y, z, material) && !map[y][z][xx][face]) {\r\n                map[y][z][xx][face] = true;\r\n                to.x = xx;\r\n            } else break;\r\n        }\r\n        for (yy = y + 1; yy <= bound.maxY; yy++) {\r\n            noSame = false;\r\n            for (xx = x; xx >= to.x; xx--) { // bottom to up\r\n                if (this.canIgnore(map, xx, yy, z, xx, yy, z - 1) || !this.isSameMaterial(map, xx, yy, z, material) || map[yy][z][xx][face]) {\r\n                    noSame = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (noSame) break;\r\n            for (xx = x; xx >= to.x; xx--) { // mark\r\n                map[yy][z][xx][face] = true;\r\n            }\r\n            to.y = yy;\r\n        }\r\n    };\r\n    Voxels.prototype.FindAndSetPointFront = function (bound, map, x, y, z, to) { // find from left-bottom to right-top in front face\r\n        var face = 'front';\r\n        var xx, yy, zz;\r\n        var material = map[y][z][x];\r\n        var noSame;\r\n        to.x = x; to.y = y; to.z = z;\r\n        for (xx = x; xx <= bound.maxX; xx++) { // facing the front, left to right and mark\r\n            if (this.canIgnore(map, xx, y, z, xx, y, z + 1)) break;\r\n            if (this.isSameMaterial(map, xx, y, z, material) && !map[y][z][xx][face]) {\r\n                map[y][z][xx][face] = true;\r\n                to.x = xx;\r\n            } else break;\r\n        }\r\n        for (yy = y + 1; yy <= bound.maxY; yy++) {\r\n            noSame = false;\r\n            for (xx = x; xx <= to.x; xx++) { // bottom to up\r\n                if (this.canIgnore(map, xx, yy, z, xx, yy, z + 1) || !this.isSameMaterial(map, xx, yy, z, material) || map[yy][z][xx][face]) {\r\n                    noSame = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (noSame) break;\r\n            for (xx = x; xx <= to.x; xx++) { // mark\r\n                map[yy][z][xx][face] = true;\r\n            }\r\n            to.y = yy;\r\n        }\r\n    };\r\n    Voxels.prototype.canIgnore = function (map, sx, sy, sz, x, y, z) {\r\n        if (!map[sy] || !map[sy][sz] || typeof map[sy][sz][sx] == 'undefined') return true;\r\n        if (map[y] && map[y][z] && typeof map[y][z][x] != 'undefined') {\r\n            if (map[sy][sz][sx].color == map[y][z][x].color) return true;\r\n        }\r\n        // return (map[y] && map[y][z] && map[y][z][x] && (typeof map[y][z][x].opacity == 'undefined' || map[y][z][x].opacity >= 1));\r\n        return false;\r\n    };\r\n    Voxels.prototype.getPointIdx = function (bound, x, y, z) { // get the first index(index 0 of the cube) of a point\r\n        var yy = y - bound.minY;\r\n        var zz = z - bound.minZ;\r\n        var xx = x - bound.minX;\r\n\r\n        var idx = yy * bound.width * bound.depth;\r\n        idx += zz * bound.width;\r\n        idx += xx;\r\n        return idx * 8;\r\n    };\r\n    Voxels.prototype.buildAFace = function (faces, a, b, c, d, vertices, color, s, t) { // build a rect face with 2 tree triangle faces and mark the associated points\r\n        // d c\r\n        // a b\r\n        faces.push([a, b, c, color, s, t]);\r\n        faces.push([a, c, d, color, s, t]);\r\n        vertices[a][3]++;\r\n        vertices[b][3]++;\r\n        vertices[c][3]++;\r\n        vertices[d][3]++;\r\n    };\r\n    Voxels.prototype.buildFaces = function (vertices) { // build all the faces, each index of the faces is the orginal one which will be updated later\r\n        var bound = this.bound;\r\n        var map = this.map;\r\n        var faces = [];\r\n        var y, z, x;\r\n        var to = { x: 0, y: 0, z: 0 };\r\n        var pointA, pointB, pointC, pointD;\r\n\r\n        if (this.showFaces.front) { // front\r\n            for (y = bound.minY; y <= bound.maxY; y++) {\r\n                if (!map[y]) continue;\r\n                for (z = bound.maxZ; z >= bound.minZ; z--) {\r\n                    if (!map[y][z]) continue;\r\n                    for (x = bound.minX; x <= bound.maxX; x++) {\r\n                        if (!map[y][z][x]) continue; // no need to handle if it is a empty block\r\n                        if (this.canIgnore(map, x, y, z, x, y, z + 1)) continue; // no need to handle if it is a middle one\r\n                        if (!map[y][z][x].front) {\r\n                            this.FindAndSetPointFront(bound, map, x, y, z, to);\r\n                            pointA = this.getPointIdx(bound, x, y, z);\r\n                            pointB = this.getPointIdx(bound, to.x, y, z);\r\n                            pointC = this.getPointIdx(bound, to.x, to.y, z);\r\n                            pointD = this.getPointIdx(bound, x, to.y, z);\r\n                            this.buildAFace(faces, pointA, pointB + 1, pointC + 2, pointD + 3, vertices, map[y][z][x], Math.abs(x - to.x) + 1, Math.abs(y - to.y) + 1);\r\n                        };\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (this.showFaces.back) { // back\r\n            for (y = bound.minY; y <= bound.maxY; y++) {\r\n                if (!map[y]) continue;\r\n                for (z = bound.minZ; z <= bound.maxZ; z++) {\r\n                    if (!map[y][z]) continue;\r\n                    for (x = bound.maxX; x >= bound.minX; x--) {\r\n                        if (!map[y][z][x]) continue; // no need to handle if it is a empty block\r\n                        if (this.canIgnore(map, x, y, z, x, y, z - 1)) continue; // no need to handle if it is a middle one\r\n                        if (!map[y][z][x].back) {\r\n                            this.FindAndSetPointBack(bound, map, x, y, z, to);\r\n                            pointA = this.getPointIdx(bound, x, y, z);\r\n                            pointB = this.getPointIdx(bound, to.x, y, z);\r\n                            pointC = this.getPointIdx(bound, to.x, to.y, z);\r\n                            pointD = this.getPointIdx(bound, x, to.y, z);\r\n                            this.buildAFace(faces, pointA + 5, pointB + 4, pointC + 7, pointD + 6, vertices, map[y][z][x], Math.abs(x - to.x) + 1, Math.abs(y - to.y) + 1);\r\n                        };\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (this.showFaces.left) { // left\r\n            for (y = bound.minY; y <= bound.maxY; y++) {\r\n                if (!map[y]) continue;\r\n                for (z = bound.minZ; z <= bound.maxZ; z++) {\r\n                    if (!map[y][z]) continue;\r\n                    for (x = bound.minX; x <= bound.maxX; x++) {\r\n                        if (!map[y][z][x]) continue; // no need to handle if it is a empty block\r\n                        if (this.canIgnore(map, x, y, z, x - 1, y, z)) continue; // no need to handle if it is a middle one\r\n                        if (!map[y][z][x].left) {\r\n                            this.FindAndSetPointLeft(bound, map, x, y, z, to);\r\n                            pointA = this.getPointIdx(bound, x, y, z);\r\n                            pointB = this.getPointIdx(bound, x, y, to.z);\r\n                            pointC = this.getPointIdx(bound, x, to.y, to.z);\r\n                            pointD = this.getPointIdx(bound, x, to.y, z);\r\n                            this.buildAFace(faces, pointA + 4, pointB, pointC + 3, pointD + 7, vertices, map[y][z][x], Math.abs(z - to.z) + 1, Math.abs(y - to.y) + 1);\r\n                        };\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (this.showFaces.right) { // right\r\n            for (y = bound.minY; y <= bound.maxY; y++) {\r\n                if (!map[y]) continue;\r\n                for (z = bound.maxZ; z >= bound.minZ; z--) {\r\n                    if (!map[y][z]) continue;\r\n                    for (x = bound.maxX; x >= bound.minX; x--) {\r\n                        if (!map[y][z][x]) continue; // no need to handle if it is a empty block\r\n                        if (this.canIgnore(map, x, y, z, x + 1, y, z)) continue; // no need to handle if it is a middle one\r\n                        if (!map[y][z][x].right) {\r\n                            this.FindAndSetPointRight(bound, map, x, y, z, to);\r\n                            pointA = this.getPointIdx(bound, x, y, z);\r\n                            pointB = this.getPointIdx(bound, x, y, to.z);\r\n                            pointC = this.getPointIdx(bound, x, to.y, to.z);\r\n                            pointD = this.getPointIdx(bound, x, to.y, z);\r\n                            this.buildAFace(faces, pointA + 1, pointB + 5, pointC + 6, pointD + 2, vertices, map[y][z][x], Math.abs(z - to.z) + 1, Math.abs(y - to.y) + 1);\r\n                        };\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (this.showFaces.top) { // top\r\n            for (y = bound.maxY; y >= bound.minY; y--) {\r\n                if (!map[y]) continue;\r\n                for (z = bound.maxZ; z >= bound.minZ; z--) {\r\n                    if (!map[y][z]) continue;\r\n                    for (x = bound.minX; x <= bound.maxX; x++) {\r\n                        if (!map[y][z][x]) continue; // no need to handle if it is a empty block\r\n                        if (this.canIgnore(map, x, y, z, x, y + 1, z)) continue; // no need to handle if it is a middle one\r\n                        if (!map[y][z][x].top) {\r\n                            this.FindAndSetPointTop(bound, map, x, y, z, to);\r\n                            pointA = this.getPointIdx(bound, x, y, z);\r\n                            pointB = this.getPointIdx(bound, to.x, y, z);\r\n                            pointC = this.getPointIdx(bound, to.x, y, to.z);\r\n                            pointD = this.getPointIdx(bound, x, y, to.z);\r\n                            this.buildAFace(faces, pointA + 3, pointB + 2, pointC + 6, pointD + 7, vertices, map[y][z][x], Math.abs(x - to.x) + 1, Math.abs(z - to.z) + 1);\r\n                        };\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (this.showFaces.bottom) { // bottom\r\n            for (y = bound.minY; y <= bound.maxY; y++) {\r\n                if (!map[y]) continue;\r\n                for (z = bound.minZ; z <= bound.maxZ; z++) {\r\n                    if (!map[y][z]) continue;\r\n                    for (x = bound.minX; x <= bound.maxX; x++) {\r\n                        if (!map[y][z][x]) continue; // no need to handle if it is a empty block\r\n                        if (this.canIgnore(map, x, y, z, x, y - 1, z)) continue; // no need to handle if it is a middle one\r\n                        if (!map[y][z][x].bottom) {\r\n                            this.FindAndSetPointBottom(bound, map, x, y, z, to);\r\n                            pointA = this.getPointIdx(bound, x, y, z);\r\n                            pointB = this.getPointIdx(bound, to.x, y, z);\r\n                            pointC = this.getPointIdx(bound, to.x, y, to.z);\r\n                            pointD = this.getPointIdx(bound, x, y, to.z);\r\n                            this.buildAFace(faces, pointA + 4, pointB + 5, pointC + 1, pointD + 0, vertices, map[y][z][x], Math.abs(x - to.x) + 1, Math.abs(z - to.z) + 1);\r\n                        };\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return faces;\r\n    };\r\n    Voxels.prototype.buildVertices = function () { // record all points including all used and unused\r\n        var bound = this.bound;\r\n        var width = this.width;\r\n        var height = this.height;\r\n        var depth = this.depth;\r\n        var center = this.center;\r\n\r\n        var vertices = [], idx = 0;\r\n        var y, z, x;\r\n        var tx, ty, tz;\r\n        var w2 = width * 0.5;\r\n        var h2 = height * 0.5;\r\n        var d2 = depth * 0.5;\r\n        for (y = bound.minY; y <= bound.maxY; y++) {\r\n            for (z = bound.minZ; z <= bound.maxZ; z++) {\r\n                for (x = bound.minX; x <= bound.maxX; x++) {\r\n                    tx = -center.x + x * width;\r\n                    ty = -center.y + y * height;\r\n                    tz = -center.z + z * depth;\r\n                    vertices.push([tx - w2, ty - h2, tz + d2, 0, idx++]); // 0 // x, y, z, usedTimes, final idx\r\n                    vertices.push([tx + w2, ty - h2, tz + d2, 0, idx++]); // 1\r\n                    vertices.push([tx + w2, ty + h2, tz + d2, 0, idx++]); // 2\r\n                    vertices.push([tx - w2, ty + h2, tz + d2, 0, idx++]); // 3\r\n                    vertices.push([tx - w2, ty - h2, tz - d2, 0, idx++]); // 4\r\n                    vertices.push([tx + w2, ty - h2, tz - d2, 0, idx++]); // 5\r\n                    vertices.push([tx + w2, ty + h2, tz - d2, 0, idx++]); // 6\r\n                    vertices.push([tx - w2, ty + h2, tz - d2, 0, idx++]); // 7\r\n                }\r\n            }\r\n        }\r\n        return vertices;\r\n    };\r\n    Voxels.prototype.getCenter2 = function (min, max, step, scale) {\r\n        return min * step + (max - min) * step * scale;\r\n        // return min + scale * (max - min) * step;\r\n    };\r\n    Voxels.prototype.getCenter = function (align, center, pCenter) {\r\n        var bound = this.bound;\r\n        var width = this.width;\r\n        var height = this.height;\r\n        var depth = this.depth;\r\n        var scaleX, scaleY, scaleZ;\r\n        var paddingX, paddingY, paddingZ;\r\n        if (typeof align == 'undefined') align = 'center';\r\n        if (typeof align == 'string') {\r\n            align = align.trim();\r\n            aligns = align.split(' ');\r\n            if (aligns.length == 3) { // different in three direct\r\n                if (aligns[0] == 'left') {\r\n                    scaleX = 0;\r\n                    paddingX = -0.5;\r\n                    pCenter.x = bound.minX;\r\n                } else if (aligns[0] == 'right') {\r\n                    scaleX = 1;\r\n                    paddingX = 0.5;\r\n                    pCenter.x = bound.maxX;\r\n                } else { // center\r\n                    scaleX = 0.5;\r\n                    paddingX = 0;\r\n                    pCenter.x = bound.minX + Math.floor(0.5 * (bound.maxX - bound.minX));\r\n                }\r\n                if (aligns[1] == 'bottom') {\r\n                    scaleY = 0;\r\n                    paddingY = -0.5;\r\n                    pCenter.y = bound.minY;\r\n                } else if (aligns[1] == 'top') {\r\n                    scaleY = 1;\r\n                    paddingY = 0.5;\r\n                    pCenter.y = bound.maxY;\r\n                } else { // center\r\n                    scaleY = 0.5;\r\n                    paddingY = 0;\r\n                    pCenter.y = bound.minY + Math.floor(0.5 * (bound.maxY - bound.minY));\r\n                }\r\n                if (aligns[2] == 'back') {\r\n                    scaleZ = 0;\r\n                    paddingZ = -0.5;\r\n                    pCenter.z = bound.minZ;\r\n                } else if (aligns[2] == 'front') {\r\n                    scaleZ = 1;\r\n                    paddingZ = 0.5;\r\n                    pCenter.z = bound.maxZ;\r\n                } else { // center\r\n                    scaleZ = 0.5;\r\n                    paddingZ = 0;\r\n                    pCenter.z = bound.minZ + Math.floor(0.5 * (bound.maxZ - bound.minZ));\r\n                }\r\n            } else { // same in three direct\r\n                if (align == 'left') {\r\n                    scaleX = scaleY = scaleZ = 0;\r\n                    paddingX = paddingY = paddingZ = -0.5;\r\n                    pCenter.x = bound.minX;\r\n                    pCenter.y = bound.minY;\r\n                    pCenter.z = bound.minZ;\r\n                } else if (align == 'right') {\r\n                    scaleX = scaleY = scaleZ = 1;\r\n                    paddingX = paddingY = paddingZ = 0.5;\r\n                    pCenter.x = bound.maxX;\r\n                    pCenter.y = bound.maxY;\r\n                    pCenter.z = bound.maxZ;\r\n                } else { // center\r\n                    scaleX = scaleY = scaleZ = 0.5;\r\n                    paddingX = paddingY = paddingZ = 0;\r\n                    pCenter.x = bound.minX + Math.floor(0.5 * (bound.maxX - bound.minX));\r\n                    pCenter.y = bound.minY + Math.floor(0.5 * (bound.maxY - bound.minY));\r\n                    pCenter.z = bound.minZ + Math.floor(0.5 * (bound.maxZ - bound.minZ));\r\n                }\r\n            }\r\n            // console.log(paddingZ, scaleZ);\r\n            center.x = this.getCenter2(bound.minX, bound.maxX, width, scaleX) + paddingX * width;\r\n            center.y = this.getCenter2(bound.minY, bound.maxY, height, scaleY) + paddingY * height;\r\n            center.z = this.getCenter2(bound.minZ, bound.maxZ, depth, scaleZ) + paddingZ * depth;\r\n        } else {\r\n            center.x = align.x;\r\n            center.y = align.y;\r\n            center.z = align.z;\r\n        }\r\n        return center;\r\n    };\r\n    Voxels.prototype.checkCellSize = function (bound) {\r\n        if (this.cellSize > 0) {\r\n            this.width = this.depth = this.height = this.cellSize / Math.max((bound.maxX - bound.minX + 1), (bound.maxZ - bound.minZ + 1));\r\n        }\r\n    };\r\n    Voxels.prototype.getBound = function (map) { // caculate the bound of the blocks\r\n        var minY = Infinity, maxY = -Infinity, minZ = Infinity, maxZ = -Infinity, minX = Infinity, maxX = -Infinity;\r\n        var y, z, x, map2, map3;\r\n        for (y in map) {\r\n            minY = Math.min(minY, y);\r\n            maxY = Math.max(maxY, y);\r\n            map2 = map[y];\r\n            for (z in map2) {\r\n                minZ = Math.min(minZ, z);\r\n                maxZ = Math.max(maxZ, z);\r\n                map3 = map2[z];\r\n                for (x in map3) {\r\n                    minX = Math.min(minX, x);\r\n                    maxX = Math.max(maxX, x);\r\n                }\r\n            }\r\n        }\r\n        return { minY: minY, maxY: maxY, minZ: minZ, maxZ: maxZ, minX: minX, maxX: maxX, width: maxX - minX + 1, height: maxY - minY + 1, depth: maxZ - minZ + 1 };\r\n    };\r\n})();\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./src/Voxels.js?");

/***/ }),

/***/ "./src/mvPly2Map.js":
/*!**************************!*\
  !*** ./src/mvPly2Map.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("(function () {\r\n    var mvPly2Map = {};\r\n    if (true) module.exports = mvPly2Map;\r\n    else {}\r\n\r\n    var _getColor = function (r, g, b) {\r\n        r = r.toString(16);\r\n        g = g.toString(16);\r\n        b = b.toString(16);\r\n        if (r.length < 2) r = '0' + r;\r\n        if (g.length < 2) g = '0' + g;\r\n        if (b.length < 2) b = '0' + b;\r\n        return '#' + r + g + b;\r\n    };\r\n\r\n    mvPly2Map.parsePly = function (plyText, needHead) {\r\n        var ply = {};\r\n        var idx = plyText.indexOf('end_header');\r\n        ply.data = plyText.substr(idx + 'end_header'.length + 2);\r\n        ply.data = (ply.data.indexOf('\\r\\n') > 0) ? ply.data.split('\\r\\n') : ply.data.split('\\n');\r\n        if (needHead) {\r\n            throw 'Not support yet';\r\n        }\r\n        return ply;\r\n    };\r\n    mvPly2Map.parse = function (plyText) {\r\n        var ply = this.parsePly(plyText);\r\n        if (!ply.data || ply.data.length < 1) throw 'No data';\r\n        var map = {}, yMap, zMap, a, x, y, z, color;\r\n        ply.data.forEach(one => {\r\n            a = one.trim().split(' ');\r\n            if (a.length == 6) {\r\n                x = parseInt(a[0]);\r\n                y = parseInt(a[2]);\r\n                z = -parseInt(a[1]);\r\n                color = _getColor(parseInt(a[3]), parseInt(a[4]), parseInt(a[5]));\r\n\r\n                yMap = map[y];\r\n                if (!yMap) yMap = map[y] = {};\r\n\r\n                zMap = yMap[z];\r\n                if (!zMap) zMap = yMap[z] = {};\r\n\r\n                // zMap[x] = { color: color };\r\n                zMap[x] = color;\r\n\r\n            }\r\n        });\r\n\r\n        return map;\r\n    };\r\n    mvPly2Map.getAllColors = function (map) {\r\n        var colors = {}, yMap, zMap;\r\n        for (var y in map) {\r\n            yMap = map[y];\r\n            for (var z in yMap) {\r\n                zMap = yMap[z];\r\n                for (var x in zMap) {\r\n                    colors[zMap[x]] = (colors[zMap[x]] || 0) + 1;\r\n                }\r\n            }\r\n        }\r\n        return colors;\r\n    };\r\n    var _afterAllCallback = function (num, cb) { // 如果有多个回调，设置后，就会在所有回调完再调用最后的一个回调\r\n        var count = 0;\r\n        return function () {\r\n            if (++count >= num) {\r\n                if (cb) {\r\n                    cb();\r\n                    cb = null;\r\n                }\r\n            }\r\n        };\r\n    };\r\n    mvPly2Map.loadPly = function (url, callback) {\r\n        var xhr = new XMLHttpRequest();\r\n        xhr.open('GET', url, true);\r\n        xhr.send();\r\n        xhr.onreadystatechange = function (e) {\r\n            if (xhr.readyState == 4 && xhr.status == 200) {\r\n                callback(xhr.responseText);\r\n            }\r\n        };\r\n    };\r\n    mvPly2Map.loadMap = function (url, callback) {\r\n        this.loadPly(url, function (data) {\r\n            callback(mvPly2Map.parse(data))\r\n        });\r\n    };\r\n    var _loadPlyFromWeb = function (plys, maps, callback) {\r\n        if (plys.length < 1) return;\r\n        var one = plys.shift();\r\n\r\n        mvPly2Map.loadMap(one.src, function (map) {\r\n            var name = one.id || one.src.split('/').pop().split('.').shift();\r\n            maps[name] = map;\r\n            callback();\r\n\r\n            _loadPlyFromWeb(plys, maps, callback);\r\n        });\r\n    };\r\n    var _loadPlys = function (cb) {\r\n        var maps = {};\r\n        var codes = document.querySelectorAll('script[type=\"text/ply\"]');\r\n        var callback = _afterAllCallback(codes.length, function () {\r\n            cb && cb(false, maps);\r\n        });\r\n        var plys = [];\r\n        for (var i = 0, one, src, id; i < codes.length; i++) {\r\n            one = codes[i];\r\n            id = one.attributes['id'] && one.attributes['id'].value.trim();\r\n            src = one.attributes['src'] && one.attributes['src'].value.trim();\r\n            if (src) {\r\n                plys.push({ src: src, id: id });\r\n            } else if (id) {\r\n                maps[id] = mvPly2Map.parse(one.innerHTML);\r\n                callback();\r\n            } else {\r\n                throw 'Src code need an id to indentify.';\r\n            }\r\n        }\r\n        _loadPlyFromWeb(plys, maps, callback);\r\n    };\r\n    mvPly2Map.parsePlys = function (cb) {\r\n\r\n        if (document.readyState == 'loading') { // 'interactive' || 'complete'\r\n            // load the default scene define in body attribute\r\n            document.addEventListener('DOMContentLoaded', function () {\r\n                document.removeEventListener('DOMContentLoaded', arguments.callee, false);\r\n                _loadPlys(cb);\r\n            }.bind(this), false);\r\n        } else _loadPlys(cb);\r\n    }\r\n    // mvPly2Map.loadPly();\r\n})();\n\n//# sourceURL=webpack:///./src/mvPly2Map.js?");

/***/ }),

/***/ "./src/voxels.aframe.js":
/*!******************************!*\
  !*** ./src/voxels.aframe.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("(function () {\r\n    var STATUS_IDLE = 0;\r\n    var STATUS_MOVE = 1;\r\n    var STATUS_TELEPROT = 2;\r\n\r\n\r\n    AFRAME.registerSystem('voxels', {\r\n        init: function () {\r\n            this.size = 0.1;\r\n            this.dir = 0; // 1 2 3 4 z+ x+ z- x-\r\n            this.ms = 0;\r\n            this.maxMs = 500;\r\n            this.teleports = {};\r\n            this.status = STATUS_IDLE;\r\n        },\r\n        addType: function (type, target, map) {\r\n            if (!type) return;\r\n            switch (type) {\r\n                case 'map': {\r\n                    console.log(map);\r\n                    this.map = map;\r\n                    this.updateTeleports()\r\n                    break;\r\n                }\r\n                case 'hero': {\r\n                    this.status = STATUS_MOVE;\r\n                    this.hero = target;\r\n                    this.heroMapPosition = { x: 0, y: 0, z: 0 };\r\n                    this.heroRotation = target.el.object3D.rotation;\r\n                    this.heroPosition = target.el.object3D.position;\r\n                    this.setHeroPos(this.heroPosition.x, this.heroPosition.y, this.heroPosition.z);\r\n                    break;\r\n                }\r\n            }\r\n        },\r\n        setHeroPos: function (x, y, z) {\r\n            if (typeof x == 'object') {\r\n                z = x.z;\r\n                y = x.y;\r\n                x = x.x;\r\n            }\r\n            this.heroMapPosition.x = x;\r\n            this.heroMapPosition.y = y;\r\n            this.heroMapPosition.z = z;\r\n            this.heroPosition.set((x - 0.5) * this.size, (y - 0) * this.size, (z - 0.5) * this.size);\r\n        },\r\n        moveHeroPos: function (xx, yy, zz) {\r\n            if (this.hero && this.map) {\r\n\r\n                var m = this.map;\r\n                var c = this.heroMapPosition;\r\n                xx = xx || 0;\r\n                yy = yy || 0;\r\n                zz = zz || 0;\r\n\r\n                // if (xx) {\r\n                //     this.chickRotation.y = (xx > 0 ? 0.5 : -0.5) * Math.PI;\r\n                // } else if (zz) {\r\n                //     this.chickRotation.y = (zz > 0 ? 0 : 1) * Math.PI;\r\n                // }\r\n\r\n                if (m[c.y + yy] && m[c.y + yy][c.z + zz] && m[c.y + yy][c.z + zz][c.x + xx]) { // 要去的地方有阻碍\r\n                    if (m[c.y + yy + 1] && m[c.y + yy + 1][c.z + zz] && m[c.y + yy + 1][c.z + zz][c.x + xx]) { // 上面走不了\r\n                        return;\r\n                    } else { // 可以向上\r\n                        if (m[c.y + 1] && m[c.y + 1][c.z] && m[c.y + 1][c.z][c.x]) return; // 如果头顶有定西，就无法向上\r\n                        yy = 1;\r\n                    }\r\n                } else { // 需要判断脚下有没有路，有才能走\r\n                    if (!m[c.y + yy - 1] || !m[c.y + yy - 1][c.z + zz] || !m[c.y + yy - 1][c.z + zz][c.x + xx]) {\r\n                        // 再看看能否下楼\r\n                        if (!m[c.y + yy - 2] || !m[c.y + yy - 2][c.z + zz] || !m[c.y + yy - 2][c.z + zz][c.x + xx]) return false;// 脚下没路，不能走\r\n                        if (m[c.y + yy - 2][c.z + zz][c.x + xx].opacity) return false; // 是水，不能进去\r\n                        yy = -1;\r\n                    } else if (m[c.y + yy - 1][c.z + zz][c.x + xx].opacity) return false; // 是水，不能进去\r\n                }\r\n\r\n                c.y += yy;\r\n                this.heroPosition.y += yy * this.size;\r\n                c.z += zz;\r\n                this.heroPosition.z += zz * this.size;\r\n                c.x += xx;\r\n                this.heroPosition.x += xx * this.size;\r\n\r\n                this.checkTeleport();\r\n            }\r\n        },\r\n        setHeroRotation: function (angle) {\r\n            this.heroRotation.y = Math.PI * angle / 180;\r\n        },\r\n        checkTeleport: function () {\r\n            var cell = this.map[this.heroMapPosition.y - 1][this.heroMapPosition.z][this.heroMapPosition.x];\r\n            if (this.teleports[cell.color]) {\r\n                this.status = STATUS_TELEPROT;\r\n                this.hero.animFadeOut(1, function () {\r\n                    this.setHeroPos(this.teleports[cell.color].x, this.teleports[cell.color].y + 1, this.teleports[cell.color].z);\r\n                    this.hero.animFadeIn(1, function () {\r\n                        this.status = STATUS_MOVE;\r\n                    }.bind(this))\r\n                }.bind(this))\r\n\r\n            }\r\n        },\r\n        updateTeleports: function () { // find all the end port\r\n            var teleports = this.teleports;\r\n            var map = this.map, yMap, zMap, y, z, x, i;\r\n            for (i in teleports) {\r\n                for (y in map) {\r\n                    yMap = map[y];\r\n                    for (z in yMap) {\r\n                        zMap = yMap[z];\r\n                        for (x in zMap) {\r\n                            if (zMap[x].color == teleports[i].color) {\r\n                                teleports[i].x = parseInt(x);\r\n                                teleports[i].y = parseInt(y);\r\n                                teleports[i].z = parseInt(z);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            console.log(this.teleports);\r\n        },\r\n        tick: function (ms, dms) {\r\n            switch (this.status) {\r\n                case STATUS_MOVE: {\r\n                    this.ms += dms;\r\n                    if (this.ms > this.maxMs) {\r\n                        while (this.ms > this.maxMs) this.ms -= this.maxMs;\r\n                        switch (this.dir) {\r\n                            case 1: { // z+\r\n                                this.moveHeroPos(0, 0, 1);\r\n                                this.setHeroRotation(0);\r\n                                break;\r\n                            }\r\n                            case 3: { // z-\r\n                                this.moveHeroPos(0, 0, -1);\r\n                                this.setHeroRotation(190);\r\n                                break;\r\n                            }\r\n                            case 2: { // x+\r\n                                this.moveHeroPos(1, 0, 0);\r\n                                this.setHeroRotation(90);\r\n                                break;\r\n                            }\r\n                            case 4: { // x-\r\n                                this.moveHeroPos(-1, 0, 0);\r\n                                this.setHeroRotation(-90);\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                    break;\r\n                }\r\n                case STATUS_TELEPROT: {\r\n                    break;\r\n                }\r\n            }\r\n        },\r\n    });\r\n\r\n    AFRAME.registerComponent('voxels-sys', {\r\n        schema: {\r\n            size: { type: 'number', default: 0.1 },\r\n            maxMs: { type: 'number', default: 500 },\r\n            teleports: {\r\n                default: {},// #cc0099_#0033ff,#cc0099_#0033ff\r\n                parse: function (value) {\r\n                    var t = {};\r\n                    if (typeof value == 'string') {\r\n                        var list = value.trim().split(',');\r\n                        list.forEach(function (one) {\r\n                            one = one.trim();\r\n                            var o = one.split('_');\r\n                            if (o.length == 2) {\r\n                                t[o[0].trim()] = { color: o[1].trim() };\r\n                            }\r\n                        })\r\n                    }\r\n                    return t;\r\n                },\r\n                stringify: function (value) {\r\n                    var txt = '';\r\n                    if (value) {\r\n                        for (var i in value) {\r\n                            if (txt) txt += ',';\r\n                            txt += i + '_' + value[i].color;\r\n                        }\r\n                    }\r\n                    return txt;\r\n                }\r\n            },\r\n        },\r\n\r\n        init: function () {\r\n            this.system = this.el.sceneEl.systems['voxels'];\r\n            this.system.size = this.data.size;\r\n            this.system.maxMs = this.data.maxMs;\r\n            this.system.teleports = this.data.teleports;\r\n        }\r\n    });\r\n\r\n    AFRAME.registerComponent('voxels', {\r\n        schema: {\r\n            map: { type: 'string', default: '' },\r\n            src: { type: 'string', default: '' },\r\n            align: { type: 'string', default: 'center center center' },\r\n            width: { type: 'number', default: 1 },\r\n            height: { type: 'number', default: 1 },\r\n            depth: { type: 'number', default: 1 },\r\n            cell: { type: 'number', default: -1 },\r\n            'cell-size': { type: 'number', default: -1 },\r\n            textures: {\r\n                default: {},// #dd0000_floor,#dddd00_box\r\n                parse: function (value) {\r\n                    var t = {};\r\n                    if (typeof value == 'string') {\r\n                        var list = value.trim().split(',');\r\n                        list.forEach(function (one) {\r\n                            one = one.trim();\r\n                            var o = one.split('_');\r\n                            if (o.length == 2) {\r\n                                t[o[0].trim()] = o[1].trim();\r\n                            }\r\n                        })\r\n                    }\r\n                    return t;\r\n                },\r\n                stringify: function (value) {\r\n                    var txt = '';\r\n                    if (value) {\r\n                        for (var i in value) {\r\n                            if (txt) txt += ',';\r\n                            txt += i + '_' + value[i];\r\n                        }\r\n                    }\r\n                    return txt;\r\n                }\r\n            },\r\n            opacities: {\r\n                default: {},// #dd0000_0.5,#dddd00_0.8\r\n                parse: function (value) {\r\n                    var t = {};\r\n                    if (typeof value == 'string') {\r\n                        var list = value.trim().split(',');\r\n                        list.forEach(function (one) {\r\n                            one = one.trim();\r\n                            var o = one.split('_');\r\n                            if (o.length == 2) {\r\n                                t[o[0].trim()] = parseFloat(o[1].trim());\r\n                            }\r\n                        })\r\n                    }\r\n                    return t;\r\n                },\r\n                stringify: function (value) {\r\n                    var txt = '';\r\n                    if (value) {\r\n                        for (var i in value) {\r\n                            if (txt) txt += ',';\r\n                            txt += i + '_' + value[i];\r\n                        }\r\n                    }\r\n                    return txt;\r\n                }\r\n            },\r\n            type: { type: 'string', default: '' },\r\n        },\r\n\r\n        init: function () {\r\n            this.animIsPlaying = false;\r\n            if ( true && this.data.src) {\r\n                mvPly2Map.loadMap(this.data.src, function (map) {\r\n                    this.data.map = map;\r\n                    this.cteateMesh();\r\n                }.bind(this));\r\n            } else this.cteateMesh();\r\n        },\r\n        cteateMesh: function () {\r\n            if (this.data.map) {\r\n                var data = this.data;\r\n                var info = {\r\n                    align: data.align,\r\n                    map: data.map,\r\n                    textures: data.textures,\r\n                    opacities: data.opacities,\r\n                    width: data.width,\r\n                    height: data.height,\r\n                    depth: data.depth,\r\n                    cellSize: data['cell-size'],\r\n                };\r\n                var colors = mvPly2Map.getAllColors(data.map);\r\n                console.log(colors);\r\n\r\n                new Voxels(info).run(function (error, mesh, map) {\r\n                    this.el.setObject3D('mesh', mesh);\r\n                    if (this.data.type) this.system.addType(this.data.type, this, map);\r\n                }.bind(this));\r\n\r\n\r\n            }\r\n        },\r\n        animFadeOut: function (dur, cb) {\r\n            var self = this;\r\n            this.time = 0;\r\n            var config = {\r\n                complete: function () {\r\n                    self.animIsPlaying = false;\r\n                    cb();\r\n                }\r\n            };\r\n            config.autoplay = false;\r\n            config.direction = 'normal';\r\n            config.duration = dur;\r\n            config.easing = 'easeInOutQuad';\r\n            config.elasticity = 400;\r\n            config.loop = 0;\r\n            config.round = false;\r\n\r\n\r\n            /*\r\n            Or we can animate values by reaching into components. For example, rather than animating property: material.opacity which would call .setAttribute on each frame, we can animate the opacity value directly with property: components.material.material.opacity. We use a dot-delimited path to walk the object tree to find the value we want to animate, and the animation process under the hood reduces down to changing a number.\r\n            */\r\n            this.animation = AFRAME.ANIME(config);\r\n\r\n\r\n        },\r\n        animFadeIn: function (s, cb) { cb(); },\r\n\r\n        tick: function (t, dt) {\r\n            if (!this.animIsPlaying) { return; }\r\n            this.time += dt;\r\n            this.animation.tick(this.time);\r\n        },\r\n    });\r\n\r\n    AFRAME.registerPrimitive('a-voxels', {\r\n        defaultComponents: {\r\n            voxels: {},\r\n        },\r\n        mappings: {\r\n            map: 'voxels.map',\r\n            src: 'voxels.src',\r\n            align: 'voxels.align',\r\n            width: 'voxels.width',\r\n            height: 'voxels.height',\r\n            depth: 'voxels.depth',\r\n            cell: 'voxels.cell',\r\n            'cell-size': 'voxels.cell-size',\r\n            textures: 'voxels.textures',\r\n            opacities: 'voxels.opacities',\r\n            type: 'voxels.type',\r\n        }\r\n    });\r\n})();\n\n//# sourceURL=webpack:///./src/voxels.aframe.js?");

/***/ }),

/***/ 0:
/*!***********************************************************************!*\
  !*** multi ./src/mvPly2Map.js ./src/Voxels.js ./src/voxels.aframe.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(/*! ./src/mvPly2Map.js */\"./src/mvPly2Map.js\");\n__webpack_require__(/*! ./src/Voxels.js */\"./src/Voxels.js\");\nmodule.exports = __webpack_require__(/*! ./src/voxels.aframe.js */\"./src/voxels.aframe.js\");\n\n\n//# sourceURL=webpack:///multi_./src/mvPly2Map.js_./src/Voxels.js_./src/voxels.aframe.js?");

/***/ })

/******/ });