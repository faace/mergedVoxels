/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./src/Voxels.js":
/*!***********************!*\
  !*** ./src/Voxels.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {// code: faaceyu\r\n// email: faace.ca@gmail.com\r\n\r\n// a cube position\r\n//   7-----6\r\n//  /|    /|\r\n// 3-+---2 |\r\n// | 4---+-5\r\n// |/    |/\r\n// 0-----1\r\n\r\n// a face position\r\n// d c\r\n// a b\r\n(function () {\r\n    var Voxels = function (info) {\r\n        this.init(info);\r\n    };\r\n\r\n    if (typeof window != 'undefined') window.Voxels = Voxels;\r\n    else if (typeof global != 'undefined') global.Voxels = Voxels;\r\n\r\n    if ( true && module.exports) module.exports = Voxels;\r\n\r\n    Voxels.prototype.init = function (info) {\r\n        this.info = info;\r\n        this.options = info.options || {};\r\n        this.map = this.copyMap(info.map || {});\r\n        this.textures = this.info.textures || {};\r\n        this.opacities = this.info.opacities || {};\r\n        this.width = info.width || 1;\r\n        this.height = info.height || 1;\r\n        this.depth = info.depth || 1;\r\n        this.cellSize = info.cellSize || -1;\r\n        this.align = info.align;\r\n        this.showFaces = info.showFaces || { front: true, back: true, left: true, right: true, top: true, bottom: true };\r\n        return this;\r\n    };\r\n    Voxels.prototype.run = function (cb) {\r\n        if (!this.bound) this.bound = this.getBound(this.map);\r\n        this.checkCellSize(this.bound);\r\n        if (!this.center) {\r\n            this.center = {};\r\n            this.pCenter = {};\r\n            this.getCenter(this.align, this.center, this.pCenter);\r\n        }\r\n        var vertices = this.buildVertices();\r\n        var faces = this.buildFaces(vertices);\r\n\r\n        this.updateVertices(vertices);\r\n        this.updateFaces(vertices, faces);\r\n\r\n        this.materials = [];\r\n        this.materialsMap = {};\r\n        this.texturesMap = {};\r\n\r\n        var geometry = this.createGeometry(vertices, faces);\r\n        var mesh = new THREE.Mesh(geometry, this.materials);\r\n        cb(false, mesh, this.centerMap(this.map));\r\n    };\r\n    Voxels.prototype.copyMap = function (map) {\r\n        var newMap = {};\r\n        for (var y in map) {\r\n            var yMap = map[y];\r\n            var newYMap = newMap[y] = {};\r\n            for (var z in yMap) {\r\n                var zMap = yMap[z];\r\n                var newZMap = newYMap[z] = {};\r\n                for (var x in zMap) {\r\n                    newZMap[x] = { color: zMap[x] };\r\n                }\r\n            }\r\n        }\r\n        return newMap;\r\n    };\r\n    Voxels.prototype.centerMap = function (map) {\r\n        var newMap = {}, one;\r\n        var opacities = this.opacities;\r\n        var textures = this.textures;\r\n        for (var y in map) {\r\n            var yMap = map[y];\r\n            var newYMap = newMap[y - this.pCenter.y] = {};\r\n            for (var z in yMap) {\r\n                var zMap = yMap[z];\r\n                var newZMap = newYMap[z - this.pCenter.z] = {};\r\n                for (var x in zMap) {\r\n                    one = { color: zMap[x].color };\r\n                    if (opacities[one.color] && opacities[one.color] < 1) one.opacity = opacities[one.color];\r\n                    if (textures[one.color]) one.texture = textures[one.color];\r\n                    newZMap[x - this.pCenter.x] = one;\r\n                }\r\n            }\r\n        }\r\n        return newMap;\r\n    };\r\n    Voxels.prototype.getMaterial = function (color, s, t) {\r\n        var textures = this.textures;\r\n        var opacity = this.opacities[color];\r\n        var parm = {};\r\n        var material;\r\n\r\n        if (this.options.polygonOffset) {\r\n            parm.polygonOffset = true;\r\n            parm.polygonOffsetFactor = this.options.polygonOffsetFactor || -1.0;\r\n            parm.polygonOffsetUnits = this.options.polygonOffsetUnits || -4.0;\r\n        }\r\n\r\n        if (textures[color]) { // check where we need to change a special color to a texture\r\n            var tag = textures[color];\r\n            var src;\r\n            if (typeof tag != 'string') src = tag.src;\r\n            else {\r\n                var img = document.querySelector('#' + textures[color]);\r\n                src = img && (img.src || img[0] && img[0].src)\r\n            }\r\n            if (src) {\r\n                var texture = new THREE.TextureLoader().load(src);\r\n                texture.wrapS = THREE.RepeatWrapping;\r\n                texture.wrapT = THREE.RepeatWrapping;\r\n                texture.repeat.set(s, t);\r\n\r\n                parm.map = texture;\r\n                material = new THREE.MeshBasicMaterial(parm);\r\n                if (typeof opacity != 'undefined') {\r\n                    material.transparent = true;\r\n                    material.opacity = opacity;\r\n                    // m.side = THREE.DoubleSide;\r\n                }\r\n                return material;\r\n            }\r\n        }\r\n\r\n        parm.color = color;\r\n        material = new THREE.MeshPhongMaterial(parm);\r\n        if (typeof opacity != 'undefined') {\r\n            material.transparent = true;\r\n            material.opacity = opacity;\r\n            // m.side = THREE.DoubleSide;\r\n        }\r\n        return material;\r\n    };\r\n    Voxels.prototype.getMaterialIdx = function (color, s, t) {\r\n        // var color = material.color;\r\n        var tag = color + '_' + s + '_' + t;\r\n        if (typeof this.materialsMap[tag] == 'undefined') {\r\n            var m = this.getMaterial(color, s, t);\r\n            this.materialsMap[tag] = this.materials.length;\r\n            this.materials.push(m);\r\n        }\r\n        return this.materialsMap[tag];\r\n    };\r\n\r\n    Voxels.prototype.createGeometry = function (vertices, faces) {\r\n        var geometry = new THREE.Geometry();\r\n        for (var i = 0; i < vertices.length; i++) {\r\n            if (vertices[i][3]) {\r\n                geometry.vertices.push(new THREE.Vector3(vertices[i][0], vertices[i][1], vertices[i][2]));\r\n            }\r\n        }\r\n        geometry.computeBoundingBox();\r\n\r\n        var faceVertexUv = geometry.faceVertexUvs[0];\r\n        var t0 = new THREE.Vector2(0, 0);\r\n        var t1 = new THREE.Vector2(1, 0);\r\n        var t2 = new THREE.Vector2(1, 1);\r\n        var t3 = new THREE.Vector2(0, 1);\r\n        var uv1 = [t0, t1, t2];\r\n        var uv2 = [t0, t2, t3];\r\n        for (var i = 0, face, idx; i < faces.length; i++) {\r\n            face = faces[i];\r\n            idx = this.getMaterialIdx(face[3].color, face[4], face[5]);\r\n            geometry.faces.push(new THREE.Face3(face[0], face[1], face[2], undefined, undefined, idx));\r\n            faceVertexUv.push(uv1, uv2);\r\n        }\r\n        // geometry.mergeVertices();\r\n        geometry.computeFaceNormals();\r\n        return geometry;\r\n    };\r\n    Voxels.prototype.updateFaces = function (vertices, faces) { // update the faces with new vertices index\r\n        for (var i = 0; i < faces.length; i++) {\r\n            faces[i][0] = vertices[faces[i][0]][4];\r\n            faces[i][1] = vertices[faces[i][1]][4];\r\n            faces[i][2] = vertices[faces[i][2]][4];\r\n        }\r\n    };\r\n    Voxels.prototype.updateVertices = function (vertices) { // mark all the used vertices so that we can remove those unused later.\r\n        var idx = 0;\r\n        for (var i = 0; i < vertices.length; i++) {\r\n            if (vertices[i][3]) vertices[i][4] = idx++;\r\n        }\r\n    };\r\n    Voxels.prototype.isSameMaterial = function (map, x, y, z, color) { // check where there are the same material\r\n        if (map[y] && map[y][z] && typeof map[y][z][x] != 'undefined') {\r\n            if (map[y][z][x] === color) return true;\r\n        }\r\n        return false\r\n    };\r\n    Voxels.prototype.FindAndSetPointBottom = function (bound, map, x, y, z, to) {// 查找同一面的右下角定点和右上角定点\r\n        var face = 'bottom';\r\n        var xx, yy, zz;\r\n        var material = map[y][z][x];\r\n        var noSame;\r\n        to.x = x; to.y = y; to.z = z;\r\n        for (xx = x; xx <= bound.maxX; xx++) { // facing the bottom, left to right and mark\r\n            if (this.canIgnore(map, xx, y, z, xx, y - 1, z)) break;\r\n            if (this.isSameMaterial(map, xx, y, z, material) && !map[y][z][xx][face]) {\r\n                map[y][z][xx][face] = true;\r\n                to.x = xx;\r\n            } else break;\r\n        }\r\n        for (zz = z + 1; zz <= bound.maxZ; zz++) {\r\n            noSame = false;\r\n            for (xx = x; xx <= to.x; xx++) { // bottom to up\r\n                if (this.canIgnore(map, xx, y, zz, xx, y - 1, zz) || !this.isSameMaterial(map, xx, y, zz, material) || map[y][zz][xx][face]) {\r\n                    noSame = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (noSame) break;\r\n            for (xx = x; xx <= to.x; xx++) { // mark\r\n                map[y][zz][xx][face] = true;\r\n            }\r\n            to.z = zz;\r\n        }\r\n    };\r\n    Voxels.prototype.FindAndSetPointTop = function (bound, map, x, y, z, to) {// 查找同一面的右下角定点和右上角定点\r\n        var face = 'top';\r\n        var xx, yy, zz;\r\n        var material = map[y][z][x];\r\n        var noSame;\r\n        to.x = x; to.y = y; to.z = z;\r\n        for (xx = x; xx <= bound.maxX; xx++) { // facing the top, left to right and mark\r\n            if (this.canIgnore(map, xx, y, z, xx, y + 1, z)) break;\r\n            if (this.isSameMaterial(map, xx, y, z, material) && !map[y][z][xx][face]) {\r\n                map[y][z][xx][face] = true;\r\n                to.x = xx;\r\n            } else break;\r\n        }\r\n        for (zz = z - 1; zz >= bound.minZ; zz--) {\r\n            noSame = false;\r\n            for (xx = x; xx <= to.x; xx++) { // bottom to up\r\n                if (this.canIgnore(map, xx, y, zz, xx, y + 1, zz) || !this.isSameMaterial(map, xx, y, zz, material) || map[y][zz][xx][face]) {\r\n                    noSame = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (noSame) break;\r\n            for (xx = x; xx <= to.x; xx++) { // mark\r\n                map[y][zz][xx][face] = true;\r\n            }\r\n            to.z = zz;\r\n        }\r\n    };\r\n\r\n    Voxels.prototype.FindAndSetPointRight = function (bound, map, x, y, z, to) {// 查找同一面的右下角定点和右上角定点\r\n        var face = 'right';\r\n        var xx, yy, zz;\r\n        var material = map[y][z][x];\r\n        var noSame;\r\n        to.x = x; to.y = y; to.z = z;\r\n        for (zz = z; zz >= bound.minZ; zz--) { // facing the rgiht, left to right and mark\r\n            if (this.canIgnore(map, x, y, zz, x + 1, y, zz)) break;\r\n            if (this.isSameMaterial(map, x, y, zz, material) && !map[y][zz][x][face]) {\r\n                map[y][zz][x][face] = true;\r\n                to.z = zz;\r\n            } else break;\r\n        }\r\n        for (yy = y + 1; yy <= bound.maxY; yy++) {\r\n            noSame = false;\r\n            for (zz = z; zz >= to.z; zz--) { // bottom to up\r\n                if (this.canIgnore(map, x, yy, zz, x + 1, yy, zz) || !this.isSameMaterial(map, x, yy, zz, material) || map[yy][zz][x][face]) {\r\n                    noSame = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (noSame) break;\r\n            for (zz = z; zz >= to.z; zz--) { // mark\r\n                map[yy][zz][x][face] = true;\r\n            }\r\n            to.y = yy;\r\n        }\r\n    };\r\n    Voxels.prototype.FindAndSetPointLeft = function (bound, map, x, y, z, to) {// 查找同一面的右下角定点和右上角定点\r\n        var face = 'left';\r\n        var xx, yy, zz;\r\n        var material = map[y][z][x];\r\n        var noSame;\r\n        to.x = x; to.y = y; to.z = z;\r\n        for (zz = z; zz <= bound.maxZ; zz++) { // facing the left, left to right and mark\r\n            if (this.canIgnore(map, x, y, zz, x - 1, y, zz)) break;\r\n            if (this.isSameMaterial(map, x, y, zz, material) && !map[y][zz][x][face]) {\r\n                map[y][zz][x][face] = true;\r\n                to.z = zz;\r\n            } else break;\r\n        }\r\n        for (yy = y + 1; yy <= bound.maxY; yy++) {\r\n            noSame = false;\r\n            for (zz = z; zz <= to.z; zz++) { // bottom to up\r\n                if (this.canIgnore(map, x, yy, zz, x - 1, yy, zz) || !this.isSameMaterial(map, x, yy, zz, material) || map[yy][zz][x][face]) {\r\n                    noSame = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (noSame) break;\r\n            for (zz = z; zz <= to.z; zz++) { // mark\r\n                map[yy][zz][x][face] = true;\r\n            }\r\n            to.y = yy;\r\n        }\r\n    };\r\n\r\n    Voxels.prototype.FindAndSetPointBack = function (bound, map, x, y, z, to) { // find from left-bottom to right-top in back face\r\n        var face = 'back';\r\n        var xx, yy, zz;\r\n        var material = map[y][z][x];\r\n        var noSame;\r\n        to.x = x; to.y = y; to.z = z;\r\n        for (xx = x; xx >= bound.minX; xx--) { // facing the back, left to right and mark\r\n            if (this.canIgnore(map, xx, y, z, xx, y, z - 1)) break;\r\n            if (this.isSameMaterial(map, xx, y, z, material) && !map[y][z][xx][face]) {\r\n                map[y][z][xx][face] = true;\r\n                to.x = xx;\r\n            } else break;\r\n        }\r\n        for (yy = y + 1; yy <= bound.maxY; yy++) {\r\n            noSame = false;\r\n            for (xx = x; xx >= to.x; xx--) { // bottom to up\r\n                if (this.canIgnore(map, xx, yy, z, xx, yy, z - 1) || !this.isSameMaterial(map, xx, yy, z, material) || map[yy][z][xx][face]) {\r\n                    noSame = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (noSame) break;\r\n            for (xx = x; xx >= to.x; xx--) { // mark\r\n                map[yy][z][xx][face] = true;\r\n            }\r\n            to.y = yy;\r\n        }\r\n    };\r\n    Voxels.prototype.FindAndSetPointFront = function (bound, map, x, y, z, to) { // find from left-bottom to right-top in front face\r\n        var face = 'front';\r\n        var xx, yy, zz;\r\n        var material = map[y][z][x];\r\n        var noSame;\r\n        to.x = x; to.y = y; to.z = z;\r\n        for (xx = x; xx <= bound.maxX; xx++) { // facing the front, left to right and mark\r\n            if (this.canIgnore(map, xx, y, z, xx, y, z + 1)) break;\r\n            if (this.isSameMaterial(map, xx, y, z, material) && !map[y][z][xx][face]) {\r\n                map[y][z][xx][face] = true;\r\n                to.x = xx;\r\n            } else break;\r\n        }\r\n        for (yy = y + 1; yy <= bound.maxY; yy++) {\r\n            noSame = false;\r\n            for (xx = x; xx <= to.x; xx++) { // bottom to up\r\n                if (this.canIgnore(map, xx, yy, z, xx, yy, z + 1) || !this.isSameMaterial(map, xx, yy, z, material) || map[yy][z][xx][face]) {\r\n                    noSame = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (noSame) break;\r\n            for (xx = x; xx <= to.x; xx++) { // mark\r\n                map[yy][z][xx][face] = true;\r\n            }\r\n            to.y = yy;\r\n        }\r\n    };\r\n    Voxels.prototype.canIgnore = function (map, sx, sy, sz, x, y, z) {\r\n        if (!map[sy] || !map[sy][sz] || typeof map[sy][sz][sx] == 'undefined') return true;\r\n        if (map[y] && map[y][z] && typeof map[y][z][x] != 'undefined') {\r\n            if (map[sy][sz][sx].color == map[y][z][x].color) return true;\r\n        }\r\n        // return (map[y] && map[y][z] && map[y][z][x] && (typeof map[y][z][x].opacity == 'undefined' || map[y][z][x].opacity >= 1));\r\n        return false;\r\n    };\r\n    Voxels.prototype.getPointIdx = function (bound, x, y, z) { // get the first index(index 0 of the cube) of a point\r\n        var yy = y - bound.minY;\r\n        var zz = z - bound.minZ;\r\n        var xx = x - bound.minX;\r\n\r\n        var idx = yy * bound.width * bound.depth;\r\n        idx += zz * bound.width;\r\n        idx += xx;\r\n        return idx * 8;\r\n    };\r\n    Voxels.prototype.buildAFace = function (faces, a, b, c, d, vertices, color, s, t) { // build a rect face with 2 tree triangle faces and mark the associated points\r\n        // d c\r\n        // a b\r\n        faces.push([a, b, c, color, s, t]);\r\n        faces.push([a, c, d, color, s, t]);\r\n        vertices[a][3]++;\r\n        vertices[b][3]++;\r\n        vertices[c][3]++;\r\n        vertices[d][3]++;\r\n    };\r\n    Voxels.prototype.buildFaces = function (vertices) { // build all the faces, each index of the faces is the orginal one which will be updated later\r\n        var bound = this.bound;\r\n        var map = this.map;\r\n        var faces = [];\r\n        var y, z, x;\r\n        var to = { x: 0, y: 0, z: 0 };\r\n        var pointA, pointB, pointC, pointD;\r\n\r\n        if (this.showFaces.front) { // front\r\n            for (y = bound.minY; y <= bound.maxY; y++) {\r\n                if (!map[y]) continue;\r\n                for (z = bound.maxZ; z >= bound.minZ; z--) {\r\n                    if (!map[y][z]) continue;\r\n                    for (x = bound.minX; x <= bound.maxX; x++) {\r\n                        if (!map[y][z][x]) continue; // no need to handle if it is a empty block\r\n                        if (this.canIgnore(map, x, y, z, x, y, z + 1)) continue; // no need to handle if it is a middle one\r\n                        if (!map[y][z][x].front) {\r\n                            this.FindAndSetPointFront(bound, map, x, y, z, to);\r\n                            pointA = this.getPointIdx(bound, x, y, z);\r\n                            pointB = this.getPointIdx(bound, to.x, y, z);\r\n                            pointC = this.getPointIdx(bound, to.x, to.y, z);\r\n                            pointD = this.getPointIdx(bound, x, to.y, z);\r\n                            this.buildAFace(faces, pointA, pointB + 1, pointC + 2, pointD + 3, vertices, map[y][z][x], Math.abs(x - to.x) + 1, Math.abs(y - to.y) + 1);\r\n                        };\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (this.showFaces.back) { // back\r\n            for (y = bound.minY; y <= bound.maxY; y++) {\r\n                if (!map[y]) continue;\r\n                for (z = bound.minZ; z <= bound.maxZ; z++) {\r\n                    if (!map[y][z]) continue;\r\n                    for (x = bound.maxX; x >= bound.minX; x--) {\r\n                        if (!map[y][z][x]) continue; // no need to handle if it is a empty block\r\n                        if (this.canIgnore(map, x, y, z, x, y, z - 1)) continue; // no need to handle if it is a middle one\r\n                        if (!map[y][z][x].back) {\r\n                            this.FindAndSetPointBack(bound, map, x, y, z, to);\r\n                            pointA = this.getPointIdx(bound, x, y, z);\r\n                            pointB = this.getPointIdx(bound, to.x, y, z);\r\n                            pointC = this.getPointIdx(bound, to.x, to.y, z);\r\n                            pointD = this.getPointIdx(bound, x, to.y, z);\r\n                            this.buildAFace(faces, pointA + 5, pointB + 4, pointC + 7, pointD + 6, vertices, map[y][z][x], Math.abs(x - to.x) + 1, Math.abs(y - to.y) + 1);\r\n                        };\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (this.showFaces.left) { // left\r\n            for (y = bound.minY; y <= bound.maxY; y++) {\r\n                if (!map[y]) continue;\r\n                for (z = bound.minZ; z <= bound.maxZ; z++) {\r\n                    if (!map[y][z]) continue;\r\n                    for (x = bound.minX; x <= bound.maxX; x++) {\r\n                        if (!map[y][z][x]) continue; // no need to handle if it is a empty block\r\n                        if (this.canIgnore(map, x, y, z, x - 1, y, z)) continue; // no need to handle if it is a middle one\r\n                        if (!map[y][z][x].left) {\r\n                            this.FindAndSetPointLeft(bound, map, x, y, z, to);\r\n                            pointA = this.getPointIdx(bound, x, y, z);\r\n                            pointB = this.getPointIdx(bound, x, y, to.z);\r\n                            pointC = this.getPointIdx(bound, x, to.y, to.z);\r\n                            pointD = this.getPointIdx(bound, x, to.y, z);\r\n                            this.buildAFace(faces, pointA + 4, pointB, pointC + 3, pointD + 7, vertices, map[y][z][x], Math.abs(z - to.z) + 1, Math.abs(y - to.y) + 1);\r\n                        };\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (this.showFaces.right) { // right\r\n            for (y = bound.minY; y <= bound.maxY; y++) {\r\n                if (!map[y]) continue;\r\n                for (z = bound.maxZ; z >= bound.minZ; z--) {\r\n                    if (!map[y][z]) continue;\r\n                    for (x = bound.maxX; x >= bound.minX; x--) {\r\n                        if (!map[y][z][x]) continue; // no need to handle if it is a empty block\r\n                        if (this.canIgnore(map, x, y, z, x + 1, y, z)) continue; // no need to handle if it is a middle one\r\n                        if (!map[y][z][x].right) {\r\n                            this.FindAndSetPointRight(bound, map, x, y, z, to);\r\n                            pointA = this.getPointIdx(bound, x, y, z);\r\n                            pointB = this.getPointIdx(bound, x, y, to.z);\r\n                            pointC = this.getPointIdx(bound, x, to.y, to.z);\r\n                            pointD = this.getPointIdx(bound, x, to.y, z);\r\n                            this.buildAFace(faces, pointA + 1, pointB + 5, pointC + 6, pointD + 2, vertices, map[y][z][x], Math.abs(z - to.z) + 1, Math.abs(y - to.y) + 1);\r\n                        };\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (this.showFaces.top) { // top\r\n            for (y = bound.maxY; y >= bound.minY; y--) {\r\n                if (!map[y]) continue;\r\n                for (z = bound.maxZ; z >= bound.minZ; z--) {\r\n                    if (!map[y][z]) continue;\r\n                    for (x = bound.minX; x <= bound.maxX; x++) {\r\n                        if (!map[y][z][x]) continue; // no need to handle if it is a empty block\r\n                        if (this.canIgnore(map, x, y, z, x, y + 1, z)) continue; // no need to handle if it is a middle one\r\n                        if (!map[y][z][x].top) {\r\n                            this.FindAndSetPointTop(bound, map, x, y, z, to);\r\n                            pointA = this.getPointIdx(bound, x, y, z);\r\n                            pointB = this.getPointIdx(bound, to.x, y, z);\r\n                            pointC = this.getPointIdx(bound, to.x, y, to.z);\r\n                            pointD = this.getPointIdx(bound, x, y, to.z);\r\n                            this.buildAFace(faces, pointA + 3, pointB + 2, pointC + 6, pointD + 7, vertices, map[y][z][x], Math.abs(x - to.x) + 1, Math.abs(z - to.z) + 1);\r\n                        };\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (this.showFaces.bottom) { // bottom\r\n            for (y = bound.minY; y <= bound.maxY; y++) {\r\n                if (!map[y]) continue;\r\n                for (z = bound.minZ; z <= bound.maxZ; z++) {\r\n                    if (!map[y][z]) continue;\r\n                    for (x = bound.minX; x <= bound.maxX; x++) {\r\n                        if (!map[y][z][x]) continue; // no need to handle if it is a empty block\r\n                        if (this.canIgnore(map, x, y, z, x, y - 1, z)) continue; // no need to handle if it is a middle one\r\n                        if (!map[y][z][x].bottom) {\r\n                            this.FindAndSetPointBottom(bound, map, x, y, z, to);\r\n                            pointA = this.getPointIdx(bound, x, y, z);\r\n                            pointB = this.getPointIdx(bound, to.x, y, z);\r\n                            pointC = this.getPointIdx(bound, to.x, y, to.z);\r\n                            pointD = this.getPointIdx(bound, x, y, to.z);\r\n                            this.buildAFace(faces, pointA + 4, pointB + 5, pointC + 1, pointD + 0, vertices, map[y][z][x], Math.abs(x - to.x) + 1, Math.abs(z - to.z) + 1);\r\n                        };\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return faces;\r\n    };\r\n    Voxels.prototype.buildVertices = function () { // record all points including all used and unused\r\n        var bound = this.bound;\r\n        var width = this.width;\r\n        var height = this.height;\r\n        var depth = this.depth;\r\n        var center = this.center;\r\n\r\n        var vertices = [], idx = 0;\r\n        var y, z, x;\r\n        var tx, ty, tz;\r\n        var w2 = width * 0.5;\r\n        var h2 = height * 0.5;\r\n        var d2 = depth * 0.5;\r\n        for (y = bound.minY; y <= bound.maxY; y++) {\r\n            for (z = bound.minZ; z <= bound.maxZ; z++) {\r\n                for (x = bound.minX; x <= bound.maxX; x++) {\r\n                    tx = -center.x + x * width;\r\n                    ty = -center.y + y * height;\r\n                    tz = -center.z + z * depth;\r\n                    vertices.push([tx - w2, ty - h2, tz + d2, 0, idx++]); // 0 // x, y, z, usedTimes, final idx\r\n                    vertices.push([tx + w2, ty - h2, tz + d2, 0, idx++]); // 1\r\n                    vertices.push([tx + w2, ty + h2, tz + d2, 0, idx++]); // 2\r\n                    vertices.push([tx - w2, ty + h2, tz + d2, 0, idx++]); // 3\r\n                    vertices.push([tx - w2, ty - h2, tz - d2, 0, idx++]); // 4\r\n                    vertices.push([tx + w2, ty - h2, tz - d2, 0, idx++]); // 5\r\n                    vertices.push([tx + w2, ty + h2, tz - d2, 0, idx++]); // 6\r\n                    vertices.push([tx - w2, ty + h2, tz - d2, 0, idx++]); // 7\r\n                }\r\n            }\r\n        }\r\n        return vertices;\r\n    };\r\n    Voxels.prototype.getCenter2 = function (min, max, step, scale) {\r\n        return min * step + (max - min) * step * scale;\r\n        // return min + scale * (max - min) * step;\r\n    };\r\n    Voxels.prototype.getCenter = function (align, center, pCenter) {\r\n        var bound = this.bound;\r\n        var width = this.width;\r\n        var height = this.height;\r\n        var depth = this.depth;\r\n        var scaleX, scaleY, scaleZ;\r\n        var paddingX, paddingY, paddingZ;\r\n        if (typeof align == 'undefined') align = 'center';\r\n        if (typeof align == 'string') {\r\n            align = align.trim();\r\n            aligns = align.split(' ');\r\n            if (aligns.length == 3) { // different in three direct\r\n                if (aligns[0] == 'left') {\r\n                    scaleX = 0;\r\n                    paddingX = -0.5;\r\n                    pCenter.x = bound.minX;\r\n                } else if (aligns[0] == 'right') {\r\n                    scaleX = 1;\r\n                    paddingX = 0.5;\r\n                    pCenter.x = bound.maxX;\r\n                } else { // center\r\n                    scaleX = 0.5;\r\n                    paddingX = 0;\r\n                    pCenter.x = bound.minX + Math.floor(0.5 * (bound.maxX - bound.minX));\r\n                }\r\n                if (aligns[1] == 'bottom') {\r\n                    scaleY = 0;\r\n                    paddingY = -0.5;\r\n                    pCenter.y = bound.minY;\r\n                } else if (aligns[1] == 'top') {\r\n                    scaleY = 1;\r\n                    paddingY = 0.5;\r\n                    pCenter.y = bound.maxY;\r\n                } else { // center\r\n                    scaleY = 0.5;\r\n                    paddingY = 0;\r\n                    pCenter.y = bound.minY + Math.floor(0.5 * (bound.maxY - bound.minY));\r\n                }\r\n                if (aligns[2] == 'back') {\r\n                    scaleZ = 0;\r\n                    paddingZ = -0.5;\r\n                    pCenter.z = bound.minZ;\r\n                } else if (aligns[2] == 'front') {\r\n                    scaleZ = 1;\r\n                    paddingZ = 0.5;\r\n                    pCenter.z = bound.maxZ;\r\n                } else { // center\r\n                    scaleZ = 0.5;\r\n                    paddingZ = 0;\r\n                    pCenter.z = bound.minZ + Math.floor(0.5 * (bound.maxZ - bound.minZ));\r\n                }\r\n            } else { // same in three direct\r\n                if (align == 'left') {\r\n                    scaleX = scaleY = scaleZ = 0;\r\n                    paddingX = paddingY = paddingZ = -0.5;\r\n                    pCenter.x = bound.minX;\r\n                    pCenter.y = bound.minY;\r\n                    pCenter.z = bound.minZ;\r\n                } else if (align == 'right') {\r\n                    scaleX = scaleY = scaleZ = 1;\r\n                    paddingX = paddingY = paddingZ = 0.5;\r\n                    pCenter.x = bound.maxX;\r\n                    pCenter.y = bound.maxY;\r\n                    pCenter.z = bound.maxZ;\r\n                } else { // center\r\n                    scaleX = scaleY = scaleZ = 0.5;\r\n                    paddingX = paddingY = paddingZ = 0;\r\n                    pCenter.x = bound.minX + Math.floor(0.5 * (bound.maxX - bound.minX));\r\n                    pCenter.y = bound.minY + Math.floor(0.5 * (bound.maxY - bound.minY));\r\n                    pCenter.z = bound.minZ + Math.floor(0.5 * (bound.maxZ - bound.minZ));\r\n                }\r\n            }\r\n            // console.log(paddingZ, scaleZ);\r\n            center.x = this.getCenter2(bound.minX, bound.maxX, width, scaleX) + paddingX * width;\r\n            center.y = this.getCenter2(bound.minY, bound.maxY, height, scaleY) + paddingY * height;\r\n            center.z = this.getCenter2(bound.minZ, bound.maxZ, depth, scaleZ) + paddingZ * depth;\r\n        } else {\r\n            center.x = align.x;\r\n            center.y = align.y;\r\n            center.z = align.z;\r\n        }\r\n        return center;\r\n    };\r\n    Voxels.prototype.checkCellSize = function (bound) {\r\n        if (this.cellSize > 0) {\r\n            this.width = this.depth = this.height = this.cellSize / Math.max((bound.maxX - bound.minX + 1), (bound.maxZ - bound.minZ + 1));\r\n        }\r\n    };\r\n    Voxels.prototype.getBound = function (map) { // caculate the bound of the blocks\r\n        var minY = Infinity, maxY = -Infinity, minZ = Infinity, maxZ = -Infinity, minX = Infinity, maxX = -Infinity;\r\n        var y, z, x, map2, map3;\r\n        for (y in map) {\r\n            minY = Math.min(minY, y);\r\n            maxY = Math.max(maxY, y);\r\n            map2 = map[y];\r\n            for (z in map2) {\r\n                minZ = Math.min(minZ, z);\r\n                maxZ = Math.max(maxZ, z);\r\n                map3 = map2[z];\r\n                for (x in map3) {\r\n                    minX = Math.min(minX, x);\r\n                    maxX = Math.max(maxX, x);\r\n                }\r\n            }\r\n        }\r\n        return { minY: minY, maxY: maxY, minZ: minZ, maxZ: maxZ, minX: minX, maxX: maxX, width: maxX - minX + 1, height: maxY - minY + 1, depth: maxZ - minZ + 1 };\r\n    };\r\n})();\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./src/Voxels.js?");

/***/ }),

/***/ 1:
/*!*****************************!*\
  !*** multi ./src/Voxels.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./src/Voxels.js */\"./src/Voxels.js\");\n\n\n//# sourceURL=webpack:///multi_./src/Voxels.js?");

/***/ })

/******/ });